<link rel="import" href="bridge-player-name.html">

<script>
((Bridge) => {

  /**
   * Calculate statics of the player with given score
   *
   * @param {Number[]} score - Array of score gained in previous games.
   * @return {[Number, Number, Number, Number]} - Tuple of statics.
   * They are combo, miss, max combo, total score.
   */
  function calcStats(score) {
    let combo = 0;
    let miss = 0;
    let maxCombo = 0;
    let sum = 0;

    score.forEach(s => {
      if (s > 0) {
        combo++;
      } else {
        if (maxCombo < combo) {
          maxCombo = combo;
        }
        combo = 0;
        miss++;
      };

      sum += s;
    });

    return [combo, miss, maxCombo, sum];
  }


  /**
   * Model of a player.
   *
   * @prop {Number} bid - Bid for the current round.
   * @prop {Number} win - Win for the curren round.
   * @prop {Number[]} score - Score of each round.
   * @prop {String} name - Name of the player.
   * @prop {Number} totalScore - Total score of all round.
   * @prop {Number} combo - Current combo of win round.
   * @prop {Number} maxCombo - Maximum combo of all round.
   * @prop {Number} miss - Number of lose round.
   * @prop {String} comment - Comment for the whole game.
   *
   * @private @prop {Object} _buffer - Buffer for calculated properties.
   *
   * @namespace Player
   * @memberof Bridge
   */
  Bridge.Player = class PlayerModel {

    /**
     * Constructor of Player object.
     *
     * @desc
     * Given parameter can be in the following form:
     * 1. null -> Create a new player with random name.
     * 2. string -> Create a new player with given string as name.
     * 3. Others -> Treat that as a player object loaded from JSON. Try to
     * Write in properties according to the object.
     *
     * @param {(null|String|Object)} base - Base of the player object to be created.
     * See description for details.
     *
     * @constructor
     */
    constructor(base) {

      // The following two properties are controlled by game service.
      this.bid = null;  // Bid for current round
      this.win = null;  // Win Trick for current round

      this._buffer = {
        lastRound: null,
        combo: null,
        miss: null,
        maxCombo: null,
        sum: null
      }

      if (typeof base === 'undefined') {
        // Whole new player.
        this.score = [];
        this.name = Bridge.randomName();
      } else if (typeof base === 'string') {
        // Given a name. Construct a new Player with given name.
        this.score = [];
        this.name = base;
      } else {
        // Load from parsed JSON object
        this.score = base.score;
        this.name = base.name;
        this.bid = base.bid;
        this.win = base.win;
      }
    }

    get totalScore() {
      this._calcStats()
      return this._buffer.sum;
    }

    get combo() {
      this._calcStats();
      return this._buffer.combo;
    }

    get miss() {
      this._calcStats();
      return this._buffer.miss;
    }

    get maxCombo() {
      this._calcStats();
      return this._buffer.maxCombo;
    }

    get comment() {
      this._calcStats();

      if (this.score.length < 3) {
        return '';
      }

      if (this.miss === 0) {
        return '(ﾉ◕ヮ◕)ﾉ*:･ﾟ✧ PERFECT ✧ﾟ･: *ヽ(◕ヮ◕ヽ)';
      }

      if (this.miss === 1) {
        return '(☞ﾟヮﾟ)☞ UCCU ☜(ﾟヮﾟ☜)';
      }

      if (this.miss === this.score.length) {
        return "Add oil (ง'̀-'́)ง";
      }

      if (this.totalScore <= 0) {
        return 'Negative score. ಠ_ಠ';
      }

      return '';
    }

    /**
     * Calculate properties for this object and save them to buffer.
     * If number of round did not change, does nothing.
     *
     * @private
     */
    _calcStats() {
      if (this._buffer.lastRound === this.score.length) {
        return;
      }
      this._buffer.lastRound = this.score.length;
      [this._buffer.combo, this._buffer.miss, this._buffer.maxCombo, this._buffer.sum] = calcStats(this.score);
    }
  }
})(Bridge);
</script>
